Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> instructions
Rule 2     instructions -> instructions instruction
Rule 3     instructions -> instruction
Rule 4     eol_instruction -> instruction ;
Rule 5     braced_instructions -> { instructions }
Rule 6     braced_instructions -> instruction ;
Rule 7     instruction -> assign
Rule 8     instruction -> if_instruction
Rule 9     instruction -> iteration_instruction
Rule 10    instruction -> return_instruction
Rule 11    instruction -> break_instruction
Rule 12    instruction -> continue_instruction
Rule 13    instruction -> print_instruction
Rule 14    assign -> variable assign_op expression ;
Rule 15    assign_op -> =
Rule 16    assign_op -> ADDASSIGN
Rule 17    assign_op -> SUBASSIGN
Rule 18    assign_op -> MULASSIGN
Rule 19    assign_op -> DIVASSIGN
Rule 20    variable -> ID
Rule 21    variable -> ID [ array_ref ]
Rule 22    array_ref -> ID
Rule 23    array_ref -> expression
Rule 24    array_ref -> array_ref , array_ref
Rule 25    expression -> variable
Rule 26    expression -> constant
Rule 27    expression -> unary_expr
Rule 28    expression -> binary_expr
Rule 29    expression -> matrix_init
Rule 30    constant -> INT
Rule 31    constant -> FLOAT
Rule 32    unary_expr -> - expression
Rule 33    unary_expr -> expression TRANSP
Rule 34    binary_expr -> expression + expression
Rule 35    binary_expr -> expression - expression
Rule 36    binary_expr -> expression * expression
Rule 37    binary_expr -> expression / expression
Rule 38    binary_expr -> expression > expression
Rule 39    binary_expr -> expression < expression
Rule 40    binary_expr -> expression EQUAL expression
Rule 41    binary_expr -> expression NOTEQUAL expression
Rule 42    binary_expr -> expression LESSEQUAL expression
Rule 43    binary_expr -> expression GREATEREQUAL expression
Rule 44    binary_expr -> expression DOTADD expression
Rule 45    binary_expr -> expression DOTSUB expression
Rule 46    binary_expr -> expression DOTMUL expression
Rule 47    binary_expr -> expression DOTDIV expression
Rule 48    matrix_init -> ZEROS ( expression )
Rule 49    matrix_init -> ZEROS ( expression , expression )
Rule 50    matrix_init -> ONES ( expression )
Rule 51    matrix_init -> ONES ( expression , expression )
Rule 52    matrix_init -> EYE ( expression )
Rule 53    matrix_init -> [ rows ; row ]
Rule 54    matrix_init -> [ row ]
Rule 55    rows -> rows ; row
Rule 56    rows -> row
Rule 57    row -> row , expression
Rule 58    row -> expression
Rule 59    break_instruction -> BREAK ;
Rule 60    continue_instruction -> CONTINUE ;
Rule 61    return_instruction -> RETURN expression ;
Rule 62    print_instruction -> PRINT string_expressions ;
Rule 63    string_expressions -> string_expressions , string_expression
Rule 64    string_expressions -> string_expression
Rule 65    string_expression -> STRING
Rule 66    string_expression -> expression
Rule 67    if_instruction -> IF ( expression ) instructions
Rule 68    if_instruction -> IF ( expression ) instructions ELSE instructions
Rule 69    if_instruction -> IF ( expression ) instructions else_if_instruction
Rule 70    if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions
Rule 71    else_if_instruction -> ELSE IF ( expression ) instructions
Rule 72    else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction
Rule 73    iteration_instruction -> WHILE ( expression ) braced_instructions
Rule 74    iteration_instruction -> FOR range_expression braced_instructions
Rule 75    range_expression -> ID = expression : expression

Terminals, with rules where they appear

(                    : 48 49 50 51 52 67 68 69 70 71 72 73
)                    : 48 49 50 51 52 67 68 69 70 71 72 73
*                    : 36
+                    : 34
,                    : 24 49 51 57 63
-                    : 32 35
/                    : 37
:                    : 75
;                    : 4 6 14 53 55 59 60 61 62
<                    : 39
=                    : 15 75
>                    : 38
ADDASSIGN            : 16
BREAK                : 59
CONTINUE             : 60
DIVASSIGN            : 19
DOTADD               : 44
DOTDIV               : 47
DOTMUL               : 46
DOTSUB               : 45
ELSE                 : 68 70 71 72
EQUAL                : 40
EYE                  : 52
FLOAT                : 31
FOR                  : 74
GREATEREQUAL         : 43
ID                   : 20 21 22 75
IF                   : 67 68 69 70 71 72
INT                  : 30
LESSEQUAL            : 42
MULASSIGN            : 18
NOTEQUAL             : 41
ONES                 : 50 51
PRINT                : 62
RETURN               : 61
STRING               : 65
SUBASSIGN            : 17
TRANSP               : 33
WHILE                : 73
ZEROS                : 48 49
[                    : 21 53 54
]                    : 21 53 54
error                : 
{                    : 5
}                    : 5

Nonterminals, with rules where they appear

array_ref            : 21 24 24
assign               : 7
assign_op            : 14
binary_expr          : 28
braced_instructions  : 73 74
break_instruction    : 11
constant             : 26
continue_instruction : 12
else_if_instruction  : 69 70 72
eol_instruction      : 
expression           : 14 23 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 49 49 50 51 51 52 57 58 61 66 67 68 69 70 71 72 73 75 75
if_instruction       : 8
instruction          : 2 3 4 6
instructions         : 1 2 5 67 68 68 69 70 70 71 72
iteration_instruction : 9
matrix_init          : 29
print_instruction    : 13
program              : 0
range_expression     : 74
return_instruction   : 10
row                  : 53 54 55 56 57
rows                 : 53 55
string_expression    : 63 64
string_expressions   : 62 63
unary_expr           : 27
variable             : 14 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . instructions
    (2) instructions -> . instructions instruction
    (3) instructions -> . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    program                        shift and go to state 1
    instructions                   shift and go to state 2
    instruction                    shift and go to state 3
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> instructions .
    (2) instructions -> instructions . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    $end            reduce using rule 1 (program -> instructions .)
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instruction                    shift and go to state 20
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 3

    (3) instructions -> instruction .

    IF              reduce using rule 3 (instructions -> instruction .)
    WHILE           reduce using rule 3 (instructions -> instruction .)
    FOR             reduce using rule 3 (instructions -> instruction .)
    RETURN          reduce using rule 3 (instructions -> instruction .)
    BREAK           reduce using rule 3 (instructions -> instruction .)
    CONTINUE        reduce using rule 3 (instructions -> instruction .)
    PRINT           reduce using rule 3 (instructions -> instruction .)
    ID              reduce using rule 3 (instructions -> instruction .)
    $end            reduce using rule 3 (instructions -> instruction .)
    }               reduce using rule 3 (instructions -> instruction .)
    ELSE            reduce using rule 3 (instructions -> instruction .)
    ;               reduce using rule 3 (instructions -> instruction .)


state 4

    (7) instruction -> assign .

    IF              reduce using rule 7 (instruction -> assign .)
    WHILE           reduce using rule 7 (instruction -> assign .)
    FOR             reduce using rule 7 (instruction -> assign .)
    RETURN          reduce using rule 7 (instruction -> assign .)
    BREAK           reduce using rule 7 (instruction -> assign .)
    CONTINUE        reduce using rule 7 (instruction -> assign .)
    PRINT           reduce using rule 7 (instruction -> assign .)
    ID              reduce using rule 7 (instruction -> assign .)
    $end            reduce using rule 7 (instruction -> assign .)
    ;               reduce using rule 7 (instruction -> assign .)
    }               reduce using rule 7 (instruction -> assign .)
    ELSE            reduce using rule 7 (instruction -> assign .)


state 5

    (8) instruction -> if_instruction .

    IF              reduce using rule 8 (instruction -> if_instruction .)
    WHILE           reduce using rule 8 (instruction -> if_instruction .)
    FOR             reduce using rule 8 (instruction -> if_instruction .)
    RETURN          reduce using rule 8 (instruction -> if_instruction .)
    BREAK           reduce using rule 8 (instruction -> if_instruction .)
    CONTINUE        reduce using rule 8 (instruction -> if_instruction .)
    PRINT           reduce using rule 8 (instruction -> if_instruction .)
    ID              reduce using rule 8 (instruction -> if_instruction .)
    $end            reduce using rule 8 (instruction -> if_instruction .)
    ;               reduce using rule 8 (instruction -> if_instruction .)
    }               reduce using rule 8 (instruction -> if_instruction .)
    ELSE            reduce using rule 8 (instruction -> if_instruction .)


state 6

    (9) instruction -> iteration_instruction .

    IF              reduce using rule 9 (instruction -> iteration_instruction .)
    WHILE           reduce using rule 9 (instruction -> iteration_instruction .)
    FOR             reduce using rule 9 (instruction -> iteration_instruction .)
    RETURN          reduce using rule 9 (instruction -> iteration_instruction .)
    BREAK           reduce using rule 9 (instruction -> iteration_instruction .)
    CONTINUE        reduce using rule 9 (instruction -> iteration_instruction .)
    PRINT           reduce using rule 9 (instruction -> iteration_instruction .)
    ID              reduce using rule 9 (instruction -> iteration_instruction .)
    $end            reduce using rule 9 (instruction -> iteration_instruction .)
    ;               reduce using rule 9 (instruction -> iteration_instruction .)
    }               reduce using rule 9 (instruction -> iteration_instruction .)
    ELSE            reduce using rule 9 (instruction -> iteration_instruction .)


state 7

    (10) instruction -> return_instruction .

    IF              reduce using rule 10 (instruction -> return_instruction .)
    WHILE           reduce using rule 10 (instruction -> return_instruction .)
    FOR             reduce using rule 10 (instruction -> return_instruction .)
    RETURN          reduce using rule 10 (instruction -> return_instruction .)
    BREAK           reduce using rule 10 (instruction -> return_instruction .)
    CONTINUE        reduce using rule 10 (instruction -> return_instruction .)
    PRINT           reduce using rule 10 (instruction -> return_instruction .)
    ID              reduce using rule 10 (instruction -> return_instruction .)
    $end            reduce using rule 10 (instruction -> return_instruction .)
    ;               reduce using rule 10 (instruction -> return_instruction .)
    }               reduce using rule 10 (instruction -> return_instruction .)
    ELSE            reduce using rule 10 (instruction -> return_instruction .)


state 8

    (11) instruction -> break_instruction .

    IF              reduce using rule 11 (instruction -> break_instruction .)
    WHILE           reduce using rule 11 (instruction -> break_instruction .)
    FOR             reduce using rule 11 (instruction -> break_instruction .)
    RETURN          reduce using rule 11 (instruction -> break_instruction .)
    BREAK           reduce using rule 11 (instruction -> break_instruction .)
    CONTINUE        reduce using rule 11 (instruction -> break_instruction .)
    PRINT           reduce using rule 11 (instruction -> break_instruction .)
    ID              reduce using rule 11 (instruction -> break_instruction .)
    $end            reduce using rule 11 (instruction -> break_instruction .)
    ;               reduce using rule 11 (instruction -> break_instruction .)
    }               reduce using rule 11 (instruction -> break_instruction .)
    ELSE            reduce using rule 11 (instruction -> break_instruction .)


state 9

    (12) instruction -> continue_instruction .

    IF              reduce using rule 12 (instruction -> continue_instruction .)
    WHILE           reduce using rule 12 (instruction -> continue_instruction .)
    FOR             reduce using rule 12 (instruction -> continue_instruction .)
    RETURN          reduce using rule 12 (instruction -> continue_instruction .)
    BREAK           reduce using rule 12 (instruction -> continue_instruction .)
    CONTINUE        reduce using rule 12 (instruction -> continue_instruction .)
    PRINT           reduce using rule 12 (instruction -> continue_instruction .)
    ID              reduce using rule 12 (instruction -> continue_instruction .)
    $end            reduce using rule 12 (instruction -> continue_instruction .)
    ;               reduce using rule 12 (instruction -> continue_instruction .)
    }               reduce using rule 12 (instruction -> continue_instruction .)
    ELSE            reduce using rule 12 (instruction -> continue_instruction .)


state 10

    (13) instruction -> print_instruction .

    IF              reduce using rule 13 (instruction -> print_instruction .)
    WHILE           reduce using rule 13 (instruction -> print_instruction .)
    FOR             reduce using rule 13 (instruction -> print_instruction .)
    RETURN          reduce using rule 13 (instruction -> print_instruction .)
    BREAK           reduce using rule 13 (instruction -> print_instruction .)
    CONTINUE        reduce using rule 13 (instruction -> print_instruction .)
    PRINT           reduce using rule 13 (instruction -> print_instruction .)
    ID              reduce using rule 13 (instruction -> print_instruction .)
    $end            reduce using rule 13 (instruction -> print_instruction .)
    ;               reduce using rule 13 (instruction -> print_instruction .)
    }               reduce using rule 13 (instruction -> print_instruction .)
    ELSE            reduce using rule 13 (instruction -> print_instruction .)


state 11

    (14) assign -> variable . assign_op expression ;
    (15) assign_op -> . =
    (16) assign_op -> . ADDASSIGN
    (17) assign_op -> . SUBASSIGN
    (18) assign_op -> . MULASSIGN
    (19) assign_op -> . DIVASSIGN

    =               shift and go to state 22
    ADDASSIGN       shift and go to state 23
    SUBASSIGN       shift and go to state 24
    MULASSIGN       shift and go to state 25
    DIVASSIGN       shift and go to state 26

    assign_op                      shift and go to state 21

state 12

    (67) if_instruction -> IF . ( expression ) instructions
    (68) if_instruction -> IF . ( expression ) instructions ELSE instructions
    (69) if_instruction -> IF . ( expression ) instructions else_if_instruction
    (70) if_instruction -> IF . ( expression ) instructions else_if_instruction ELSE instructions

    (               shift and go to state 27


state 13

    (73) iteration_instruction -> WHILE . ( expression ) braced_instructions

    (               shift and go to state 28


state 14

    (74) iteration_instruction -> FOR . range_expression braced_instructions
    (75) range_expression -> . ID = expression : expression

    ID              shift and go to state 30

    range_expression               shift and go to state 29

state 15

    (61) return_instruction -> RETURN . expression ;
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 31
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 16

    (59) break_instruction -> BREAK . ;

    ;               shift and go to state 44


state 17

    (60) continue_instruction -> CONTINUE . ;

    ;               shift and go to state 45


state 18

    (62) print_instruction -> PRINT . string_expressions ;
    (63) string_expressions -> . string_expressions , string_expression
    (64) string_expressions -> . string_expression
    (65) string_expression -> . STRING
    (66) string_expression -> . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    STRING          shift and go to state 48
    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    string_expressions             shift and go to state 46
    string_expression              shift and go to state 47
    expression                     shift and go to state 49
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 19

    (20) variable -> ID .
    (21) variable -> ID . [ array_ref ]

    =               reduce using rule 20 (variable -> ID .)
    ADDASSIGN       reduce using rule 20 (variable -> ID .)
    SUBASSIGN       reduce using rule 20 (variable -> ID .)
    MULASSIGN       reduce using rule 20 (variable -> ID .)
    DIVASSIGN       reduce using rule 20 (variable -> ID .)
    ;               reduce using rule 20 (variable -> ID .)
    TRANSP          reduce using rule 20 (variable -> ID .)
    +               reduce using rule 20 (variable -> ID .)
    -               reduce using rule 20 (variable -> ID .)
    *               reduce using rule 20 (variable -> ID .)
    /               reduce using rule 20 (variable -> ID .)
    >               reduce using rule 20 (variable -> ID .)
    <               reduce using rule 20 (variable -> ID .)
    EQUAL           reduce using rule 20 (variable -> ID .)
    NOTEQUAL        reduce using rule 20 (variable -> ID .)
    LESSEQUAL       reduce using rule 20 (variable -> ID .)
    GREATEREQUAL    reduce using rule 20 (variable -> ID .)
    DOTADD          reduce using rule 20 (variable -> ID .)
    DOTSUB          reduce using rule 20 (variable -> ID .)
    DOTMUL          reduce using rule 20 (variable -> ID .)
    DOTDIV          reduce using rule 20 (variable -> ID .)
    ,               reduce using rule 20 (variable -> ID .)
    )               reduce using rule 20 (variable -> ID .)
    ]               reduce using rule 20 (variable -> ID .)
    :               reduce using rule 20 (variable -> ID .)
    {               reduce using rule 20 (variable -> ID .)
    IF              reduce using rule 20 (variable -> ID .)
    WHILE           reduce using rule 20 (variable -> ID .)
    FOR             reduce using rule 20 (variable -> ID .)
    RETURN          reduce using rule 20 (variable -> ID .)
    BREAK           reduce using rule 20 (variable -> ID .)
    CONTINUE        reduce using rule 20 (variable -> ID .)
    PRINT           reduce using rule 20 (variable -> ID .)
    ID              reduce using rule 20 (variable -> ID .)
    [               shift and go to state 50


state 20

    (2) instructions -> instructions instruction .

    IF              reduce using rule 2 (instructions -> instructions instruction .)
    WHILE           reduce using rule 2 (instructions -> instructions instruction .)
    FOR             reduce using rule 2 (instructions -> instructions instruction .)
    RETURN          reduce using rule 2 (instructions -> instructions instruction .)
    BREAK           reduce using rule 2 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 2 (instructions -> instructions instruction .)
    PRINT           reduce using rule 2 (instructions -> instructions instruction .)
    ID              reduce using rule 2 (instructions -> instructions instruction .)
    $end            reduce using rule 2 (instructions -> instructions instruction .)
    }               reduce using rule 2 (instructions -> instructions instruction .)
    ELSE            reduce using rule 2 (instructions -> instructions instruction .)
    ;               reduce using rule 2 (instructions -> instructions instruction .)


state 21

    (14) assign -> variable assign_op . expression ;
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    variable                       shift and go to state 32
    expression                     shift and go to state 51
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 22

    (15) assign_op -> = .

    ID              reduce using rule 15 (assign_op -> = .)
    INT             reduce using rule 15 (assign_op -> = .)
    FLOAT           reduce using rule 15 (assign_op -> = .)
    -               reduce using rule 15 (assign_op -> = .)
    ZEROS           reduce using rule 15 (assign_op -> = .)
    ONES            reduce using rule 15 (assign_op -> = .)
    EYE             reduce using rule 15 (assign_op -> = .)
    [               reduce using rule 15 (assign_op -> = .)


state 23

    (16) assign_op -> ADDASSIGN .

    ID              reduce using rule 16 (assign_op -> ADDASSIGN .)
    INT             reduce using rule 16 (assign_op -> ADDASSIGN .)
    FLOAT           reduce using rule 16 (assign_op -> ADDASSIGN .)
    -               reduce using rule 16 (assign_op -> ADDASSIGN .)
    ZEROS           reduce using rule 16 (assign_op -> ADDASSIGN .)
    ONES            reduce using rule 16 (assign_op -> ADDASSIGN .)
    EYE             reduce using rule 16 (assign_op -> ADDASSIGN .)
    [               reduce using rule 16 (assign_op -> ADDASSIGN .)


state 24

    (17) assign_op -> SUBASSIGN .

    ID              reduce using rule 17 (assign_op -> SUBASSIGN .)
    INT             reduce using rule 17 (assign_op -> SUBASSIGN .)
    FLOAT           reduce using rule 17 (assign_op -> SUBASSIGN .)
    -               reduce using rule 17 (assign_op -> SUBASSIGN .)
    ZEROS           reduce using rule 17 (assign_op -> SUBASSIGN .)
    ONES            reduce using rule 17 (assign_op -> SUBASSIGN .)
    EYE             reduce using rule 17 (assign_op -> SUBASSIGN .)
    [               reduce using rule 17 (assign_op -> SUBASSIGN .)


state 25

    (18) assign_op -> MULASSIGN .

    ID              reduce using rule 18 (assign_op -> MULASSIGN .)
    INT             reduce using rule 18 (assign_op -> MULASSIGN .)
    FLOAT           reduce using rule 18 (assign_op -> MULASSIGN .)
    -               reduce using rule 18 (assign_op -> MULASSIGN .)
    ZEROS           reduce using rule 18 (assign_op -> MULASSIGN .)
    ONES            reduce using rule 18 (assign_op -> MULASSIGN .)
    EYE             reduce using rule 18 (assign_op -> MULASSIGN .)
    [               reduce using rule 18 (assign_op -> MULASSIGN .)


state 26

    (19) assign_op -> DIVASSIGN .

    ID              reduce using rule 19 (assign_op -> DIVASSIGN .)
    INT             reduce using rule 19 (assign_op -> DIVASSIGN .)
    FLOAT           reduce using rule 19 (assign_op -> DIVASSIGN .)
    -               reduce using rule 19 (assign_op -> DIVASSIGN .)
    ZEROS           reduce using rule 19 (assign_op -> DIVASSIGN .)
    ONES            reduce using rule 19 (assign_op -> DIVASSIGN .)
    EYE             reduce using rule 19 (assign_op -> DIVASSIGN .)
    [               reduce using rule 19 (assign_op -> DIVASSIGN .)


state 27

    (67) if_instruction -> IF ( . expression ) instructions
    (68) if_instruction -> IF ( . expression ) instructions ELSE instructions
    (69) if_instruction -> IF ( . expression ) instructions else_if_instruction
    (70) if_instruction -> IF ( . expression ) instructions else_if_instruction ELSE instructions
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 52
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 28

    (73) iteration_instruction -> WHILE ( . expression ) braced_instructions
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 53
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 29

    (74) iteration_instruction -> FOR range_expression . braced_instructions
    (5) braced_instructions -> . { instructions }
    (6) braced_instructions -> . instruction ;
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    {               shift and go to state 55
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    braced_instructions            shift and go to state 54
    instruction                    shift and go to state 56
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 30

    (75) range_expression -> ID . = expression : expression

    =               shift and go to state 57


state 31

    (61) return_instruction -> RETURN expression . ;
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               shift and go to state 58
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 32

    (25) expression -> variable .

    ;               reduce using rule 25 (expression -> variable .)
    TRANSP          reduce using rule 25 (expression -> variable .)
    +               reduce using rule 25 (expression -> variable .)
    -               reduce using rule 25 (expression -> variable .)
    *               reduce using rule 25 (expression -> variable .)
    /               reduce using rule 25 (expression -> variable .)
    >               reduce using rule 25 (expression -> variable .)
    <               reduce using rule 25 (expression -> variable .)
    EQUAL           reduce using rule 25 (expression -> variable .)
    NOTEQUAL        reduce using rule 25 (expression -> variable .)
    LESSEQUAL       reduce using rule 25 (expression -> variable .)
    GREATEREQUAL    reduce using rule 25 (expression -> variable .)
    DOTADD          reduce using rule 25 (expression -> variable .)
    DOTSUB          reduce using rule 25 (expression -> variable .)
    DOTMUL          reduce using rule 25 (expression -> variable .)
    DOTDIV          reduce using rule 25 (expression -> variable .)
    ,               reduce using rule 25 (expression -> variable .)
    )               reduce using rule 25 (expression -> variable .)
    ]               reduce using rule 25 (expression -> variable .)
    :               reduce using rule 25 (expression -> variable .)
    {               reduce using rule 25 (expression -> variable .)
    IF              reduce using rule 25 (expression -> variable .)
    WHILE           reduce using rule 25 (expression -> variable .)
    FOR             reduce using rule 25 (expression -> variable .)
    RETURN          reduce using rule 25 (expression -> variable .)
    BREAK           reduce using rule 25 (expression -> variable .)
    CONTINUE        reduce using rule 25 (expression -> variable .)
    PRINT           reduce using rule 25 (expression -> variable .)
    ID              reduce using rule 25 (expression -> variable .)


state 33

    (26) expression -> constant .

    ;               reduce using rule 26 (expression -> constant .)
    TRANSP          reduce using rule 26 (expression -> constant .)
    +               reduce using rule 26 (expression -> constant .)
    -               reduce using rule 26 (expression -> constant .)
    *               reduce using rule 26 (expression -> constant .)
    /               reduce using rule 26 (expression -> constant .)
    >               reduce using rule 26 (expression -> constant .)
    <               reduce using rule 26 (expression -> constant .)
    EQUAL           reduce using rule 26 (expression -> constant .)
    NOTEQUAL        reduce using rule 26 (expression -> constant .)
    LESSEQUAL       reduce using rule 26 (expression -> constant .)
    GREATEREQUAL    reduce using rule 26 (expression -> constant .)
    DOTADD          reduce using rule 26 (expression -> constant .)
    DOTSUB          reduce using rule 26 (expression -> constant .)
    DOTMUL          reduce using rule 26 (expression -> constant .)
    DOTDIV          reduce using rule 26 (expression -> constant .)
    ,               reduce using rule 26 (expression -> constant .)
    )               reduce using rule 26 (expression -> constant .)
    ]               reduce using rule 26 (expression -> constant .)
    :               reduce using rule 26 (expression -> constant .)
    {               reduce using rule 26 (expression -> constant .)
    IF              reduce using rule 26 (expression -> constant .)
    WHILE           reduce using rule 26 (expression -> constant .)
    FOR             reduce using rule 26 (expression -> constant .)
    RETURN          reduce using rule 26 (expression -> constant .)
    BREAK           reduce using rule 26 (expression -> constant .)
    CONTINUE        reduce using rule 26 (expression -> constant .)
    PRINT           reduce using rule 26 (expression -> constant .)
    ID              reduce using rule 26 (expression -> constant .)


state 34

    (27) expression -> unary_expr .

    ;               reduce using rule 27 (expression -> unary_expr .)
    TRANSP          reduce using rule 27 (expression -> unary_expr .)
    +               reduce using rule 27 (expression -> unary_expr .)
    -               reduce using rule 27 (expression -> unary_expr .)
    *               reduce using rule 27 (expression -> unary_expr .)
    /               reduce using rule 27 (expression -> unary_expr .)
    >               reduce using rule 27 (expression -> unary_expr .)
    <               reduce using rule 27 (expression -> unary_expr .)
    EQUAL           reduce using rule 27 (expression -> unary_expr .)
    NOTEQUAL        reduce using rule 27 (expression -> unary_expr .)
    LESSEQUAL       reduce using rule 27 (expression -> unary_expr .)
    GREATEREQUAL    reduce using rule 27 (expression -> unary_expr .)
    DOTADD          reduce using rule 27 (expression -> unary_expr .)
    DOTSUB          reduce using rule 27 (expression -> unary_expr .)
    DOTMUL          reduce using rule 27 (expression -> unary_expr .)
    DOTDIV          reduce using rule 27 (expression -> unary_expr .)
    ,               reduce using rule 27 (expression -> unary_expr .)
    )               reduce using rule 27 (expression -> unary_expr .)
    ]               reduce using rule 27 (expression -> unary_expr .)
    :               reduce using rule 27 (expression -> unary_expr .)
    {               reduce using rule 27 (expression -> unary_expr .)
    IF              reduce using rule 27 (expression -> unary_expr .)
    WHILE           reduce using rule 27 (expression -> unary_expr .)
    FOR             reduce using rule 27 (expression -> unary_expr .)
    RETURN          reduce using rule 27 (expression -> unary_expr .)
    BREAK           reduce using rule 27 (expression -> unary_expr .)
    CONTINUE        reduce using rule 27 (expression -> unary_expr .)
    PRINT           reduce using rule 27 (expression -> unary_expr .)
    ID              reduce using rule 27 (expression -> unary_expr .)


state 35

    (28) expression -> binary_expr .

    ;               reduce using rule 28 (expression -> binary_expr .)
    TRANSP          reduce using rule 28 (expression -> binary_expr .)
    +               reduce using rule 28 (expression -> binary_expr .)
    -               reduce using rule 28 (expression -> binary_expr .)
    *               reduce using rule 28 (expression -> binary_expr .)
    /               reduce using rule 28 (expression -> binary_expr .)
    >               reduce using rule 28 (expression -> binary_expr .)
    <               reduce using rule 28 (expression -> binary_expr .)
    EQUAL           reduce using rule 28 (expression -> binary_expr .)
    NOTEQUAL        reduce using rule 28 (expression -> binary_expr .)
    LESSEQUAL       reduce using rule 28 (expression -> binary_expr .)
    GREATEREQUAL    reduce using rule 28 (expression -> binary_expr .)
    DOTADD          reduce using rule 28 (expression -> binary_expr .)
    DOTSUB          reduce using rule 28 (expression -> binary_expr .)
    DOTMUL          reduce using rule 28 (expression -> binary_expr .)
    DOTDIV          reduce using rule 28 (expression -> binary_expr .)
    ,               reduce using rule 28 (expression -> binary_expr .)
    )               reduce using rule 28 (expression -> binary_expr .)
    ]               reduce using rule 28 (expression -> binary_expr .)
    :               reduce using rule 28 (expression -> binary_expr .)
    {               reduce using rule 28 (expression -> binary_expr .)
    IF              reduce using rule 28 (expression -> binary_expr .)
    WHILE           reduce using rule 28 (expression -> binary_expr .)
    FOR             reduce using rule 28 (expression -> binary_expr .)
    RETURN          reduce using rule 28 (expression -> binary_expr .)
    BREAK           reduce using rule 28 (expression -> binary_expr .)
    CONTINUE        reduce using rule 28 (expression -> binary_expr .)
    PRINT           reduce using rule 28 (expression -> binary_expr .)
    ID              reduce using rule 28 (expression -> binary_expr .)


state 36

    (29) expression -> matrix_init .

    ;               reduce using rule 29 (expression -> matrix_init .)
    TRANSP          reduce using rule 29 (expression -> matrix_init .)
    +               reduce using rule 29 (expression -> matrix_init .)
    -               reduce using rule 29 (expression -> matrix_init .)
    *               reduce using rule 29 (expression -> matrix_init .)
    /               reduce using rule 29 (expression -> matrix_init .)
    >               reduce using rule 29 (expression -> matrix_init .)
    <               reduce using rule 29 (expression -> matrix_init .)
    EQUAL           reduce using rule 29 (expression -> matrix_init .)
    NOTEQUAL        reduce using rule 29 (expression -> matrix_init .)
    LESSEQUAL       reduce using rule 29 (expression -> matrix_init .)
    GREATEREQUAL    reduce using rule 29 (expression -> matrix_init .)
    DOTADD          reduce using rule 29 (expression -> matrix_init .)
    DOTSUB          reduce using rule 29 (expression -> matrix_init .)
    DOTMUL          reduce using rule 29 (expression -> matrix_init .)
    DOTDIV          reduce using rule 29 (expression -> matrix_init .)
    ,               reduce using rule 29 (expression -> matrix_init .)
    )               reduce using rule 29 (expression -> matrix_init .)
    ]               reduce using rule 29 (expression -> matrix_init .)
    :               reduce using rule 29 (expression -> matrix_init .)
    {               reduce using rule 29 (expression -> matrix_init .)
    IF              reduce using rule 29 (expression -> matrix_init .)
    WHILE           reduce using rule 29 (expression -> matrix_init .)
    FOR             reduce using rule 29 (expression -> matrix_init .)
    RETURN          reduce using rule 29 (expression -> matrix_init .)
    BREAK           reduce using rule 29 (expression -> matrix_init .)
    CONTINUE        reduce using rule 29 (expression -> matrix_init .)
    PRINT           reduce using rule 29 (expression -> matrix_init .)
    ID              reduce using rule 29 (expression -> matrix_init .)


state 37

    (53) matrix_init -> [ . rows ; row ]
    (54) matrix_init -> [ . row ]
    (55) rows -> . rows ; row
    (56) rows -> . row
    (57) row -> . row , expression
    (58) row -> . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    rows                           shift and go to state 74
    row                            shift and go to state 75
    expression                     shift and go to state 76
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 38

    (30) constant -> INT .

    ;               reduce using rule 30 (constant -> INT .)
    TRANSP          reduce using rule 30 (constant -> INT .)
    +               reduce using rule 30 (constant -> INT .)
    -               reduce using rule 30 (constant -> INT .)
    *               reduce using rule 30 (constant -> INT .)
    /               reduce using rule 30 (constant -> INT .)
    >               reduce using rule 30 (constant -> INT .)
    <               reduce using rule 30 (constant -> INT .)
    EQUAL           reduce using rule 30 (constant -> INT .)
    NOTEQUAL        reduce using rule 30 (constant -> INT .)
    LESSEQUAL       reduce using rule 30 (constant -> INT .)
    GREATEREQUAL    reduce using rule 30 (constant -> INT .)
    DOTADD          reduce using rule 30 (constant -> INT .)
    DOTSUB          reduce using rule 30 (constant -> INT .)
    DOTMUL          reduce using rule 30 (constant -> INT .)
    DOTDIV          reduce using rule 30 (constant -> INT .)
    ,               reduce using rule 30 (constant -> INT .)
    )               reduce using rule 30 (constant -> INT .)
    ]               reduce using rule 30 (constant -> INT .)
    :               reduce using rule 30 (constant -> INT .)
    {               reduce using rule 30 (constant -> INT .)
    IF              reduce using rule 30 (constant -> INT .)
    WHILE           reduce using rule 30 (constant -> INT .)
    FOR             reduce using rule 30 (constant -> INT .)
    RETURN          reduce using rule 30 (constant -> INT .)
    BREAK           reduce using rule 30 (constant -> INT .)
    CONTINUE        reduce using rule 30 (constant -> INT .)
    PRINT           reduce using rule 30 (constant -> INT .)
    ID              reduce using rule 30 (constant -> INT .)


state 39

    (31) constant -> FLOAT .

    ;               reduce using rule 31 (constant -> FLOAT .)
    TRANSP          reduce using rule 31 (constant -> FLOAT .)
    +               reduce using rule 31 (constant -> FLOAT .)
    -               reduce using rule 31 (constant -> FLOAT .)
    *               reduce using rule 31 (constant -> FLOAT .)
    /               reduce using rule 31 (constant -> FLOAT .)
    >               reduce using rule 31 (constant -> FLOAT .)
    <               reduce using rule 31 (constant -> FLOAT .)
    EQUAL           reduce using rule 31 (constant -> FLOAT .)
    NOTEQUAL        reduce using rule 31 (constant -> FLOAT .)
    LESSEQUAL       reduce using rule 31 (constant -> FLOAT .)
    GREATEREQUAL    reduce using rule 31 (constant -> FLOAT .)
    DOTADD          reduce using rule 31 (constant -> FLOAT .)
    DOTSUB          reduce using rule 31 (constant -> FLOAT .)
    DOTMUL          reduce using rule 31 (constant -> FLOAT .)
    DOTDIV          reduce using rule 31 (constant -> FLOAT .)
    ,               reduce using rule 31 (constant -> FLOAT .)
    )               reduce using rule 31 (constant -> FLOAT .)
    ]               reduce using rule 31 (constant -> FLOAT .)
    :               reduce using rule 31 (constant -> FLOAT .)
    {               reduce using rule 31 (constant -> FLOAT .)
    IF              reduce using rule 31 (constant -> FLOAT .)
    WHILE           reduce using rule 31 (constant -> FLOAT .)
    FOR             reduce using rule 31 (constant -> FLOAT .)
    RETURN          reduce using rule 31 (constant -> FLOAT .)
    BREAK           reduce using rule 31 (constant -> FLOAT .)
    CONTINUE        reduce using rule 31 (constant -> FLOAT .)
    PRINT           reduce using rule 31 (constant -> FLOAT .)
    ID              reduce using rule 31 (constant -> FLOAT .)


state 40

    (32) unary_expr -> - . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 77
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 41

    (48) matrix_init -> ZEROS . ( expression )
    (49) matrix_init -> ZEROS . ( expression , expression )

    (               shift and go to state 78


state 42

    (50) matrix_init -> ONES . ( expression )
    (51) matrix_init -> ONES . ( expression , expression )

    (               shift and go to state 79


state 43

    (52) matrix_init -> EYE . ( expression )

    (               shift and go to state 80


state 44

    (59) break_instruction -> BREAK ; .

    IF              reduce using rule 59 (break_instruction -> BREAK ; .)
    WHILE           reduce using rule 59 (break_instruction -> BREAK ; .)
    FOR             reduce using rule 59 (break_instruction -> BREAK ; .)
    RETURN          reduce using rule 59 (break_instruction -> BREAK ; .)
    BREAK           reduce using rule 59 (break_instruction -> BREAK ; .)
    CONTINUE        reduce using rule 59 (break_instruction -> BREAK ; .)
    PRINT           reduce using rule 59 (break_instruction -> BREAK ; .)
    ID              reduce using rule 59 (break_instruction -> BREAK ; .)
    $end            reduce using rule 59 (break_instruction -> BREAK ; .)
    ;               reduce using rule 59 (break_instruction -> BREAK ; .)
    }               reduce using rule 59 (break_instruction -> BREAK ; .)
    ELSE            reduce using rule 59 (break_instruction -> BREAK ; .)


state 45

    (60) continue_instruction -> CONTINUE ; .

    IF              reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    WHILE           reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    FOR             reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    RETURN          reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    BREAK           reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    CONTINUE        reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    PRINT           reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    ID              reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    $end            reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    ;               reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    }               reduce using rule 60 (continue_instruction -> CONTINUE ; .)
    ELSE            reduce using rule 60 (continue_instruction -> CONTINUE ; .)


state 46

    (62) print_instruction -> PRINT string_expressions . ;
    (63) string_expressions -> string_expressions . , string_expression

    ;               shift and go to state 81
    ,               shift and go to state 82


state 47

    (64) string_expressions -> string_expression .

    ;               reduce using rule 64 (string_expressions -> string_expression .)
    ,               reduce using rule 64 (string_expressions -> string_expression .)


state 48

    (65) string_expression -> STRING .

    ;               reduce using rule 65 (string_expression -> STRING .)
    ,               reduce using rule 65 (string_expression -> STRING .)


state 49

    (66) string_expression -> expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 66 (string_expression -> expression .)
    ,               reduce using rule 66 (string_expression -> expression .)
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 50

    (21) variable -> ID [ . array_ref ]
    (22) array_ref -> . ID
    (23) array_ref -> . expression
    (24) array_ref -> . array_ref , array_ref
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 83
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    array_ref                      shift and go to state 84
    expression                     shift and go to state 85
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 51

    (14) assign -> variable assign_op expression . ;
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               shift and go to state 86
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 52

    (67) if_instruction -> IF ( expression . ) instructions
    (68) if_instruction -> IF ( expression . ) instructions ELSE instructions
    (69) if_instruction -> IF ( expression . ) instructions else_if_instruction
    (70) if_instruction -> IF ( expression . ) instructions else_if_instruction ELSE instructions
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 87
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 53

    (73) iteration_instruction -> WHILE ( expression . ) braced_instructions
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 88
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 54

    (74) iteration_instruction -> FOR range_expression braced_instructions .

    IF              reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    WHILE           reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    FOR             reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    RETURN          reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    BREAK           reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    CONTINUE        reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    PRINT           reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    ID              reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    $end            reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    ;               reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    }               reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)
    ELSE            reduce using rule 74 (iteration_instruction -> FOR range_expression braced_instructions .)


state 55

    (5) braced_instructions -> { . instructions }
    (2) instructions -> . instructions instruction
    (3) instructions -> . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instructions                   shift and go to state 89
    instruction                    shift and go to state 3
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 56

    (6) braced_instructions -> instruction . ;

    ;               shift and go to state 90


state 57

    (75) range_expression -> ID = . expression : expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 91
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 58

    (61) return_instruction -> RETURN expression ; .

    IF              reduce using rule 61 (return_instruction -> RETURN expression ; .)
    WHILE           reduce using rule 61 (return_instruction -> RETURN expression ; .)
    FOR             reduce using rule 61 (return_instruction -> RETURN expression ; .)
    RETURN          reduce using rule 61 (return_instruction -> RETURN expression ; .)
    BREAK           reduce using rule 61 (return_instruction -> RETURN expression ; .)
    CONTINUE        reduce using rule 61 (return_instruction -> RETURN expression ; .)
    PRINT           reduce using rule 61 (return_instruction -> RETURN expression ; .)
    ID              reduce using rule 61 (return_instruction -> RETURN expression ; .)
    $end            reduce using rule 61 (return_instruction -> RETURN expression ; .)
    ;               reduce using rule 61 (return_instruction -> RETURN expression ; .)
    }               reduce using rule 61 (return_instruction -> RETURN expression ; .)
    ELSE            reduce using rule 61 (return_instruction -> RETURN expression ; .)


state 59

    (33) unary_expr -> expression TRANSP .

    ;               reduce using rule 33 (unary_expr -> expression TRANSP .)
    TRANSP          reduce using rule 33 (unary_expr -> expression TRANSP .)
    +               reduce using rule 33 (unary_expr -> expression TRANSP .)
    -               reduce using rule 33 (unary_expr -> expression TRANSP .)
    *               reduce using rule 33 (unary_expr -> expression TRANSP .)
    /               reduce using rule 33 (unary_expr -> expression TRANSP .)
    >               reduce using rule 33 (unary_expr -> expression TRANSP .)
    <               reduce using rule 33 (unary_expr -> expression TRANSP .)
    EQUAL           reduce using rule 33 (unary_expr -> expression TRANSP .)
    NOTEQUAL        reduce using rule 33 (unary_expr -> expression TRANSP .)
    LESSEQUAL       reduce using rule 33 (unary_expr -> expression TRANSP .)
    GREATEREQUAL    reduce using rule 33 (unary_expr -> expression TRANSP .)
    DOTADD          reduce using rule 33 (unary_expr -> expression TRANSP .)
    DOTSUB          reduce using rule 33 (unary_expr -> expression TRANSP .)
    DOTMUL          reduce using rule 33 (unary_expr -> expression TRANSP .)
    DOTDIV          reduce using rule 33 (unary_expr -> expression TRANSP .)
    ,               reduce using rule 33 (unary_expr -> expression TRANSP .)
    )               reduce using rule 33 (unary_expr -> expression TRANSP .)
    ]               reduce using rule 33 (unary_expr -> expression TRANSP .)
    :               reduce using rule 33 (unary_expr -> expression TRANSP .)
    {               reduce using rule 33 (unary_expr -> expression TRANSP .)
    IF              reduce using rule 33 (unary_expr -> expression TRANSP .)
    WHILE           reduce using rule 33 (unary_expr -> expression TRANSP .)
    FOR             reduce using rule 33 (unary_expr -> expression TRANSP .)
    RETURN          reduce using rule 33 (unary_expr -> expression TRANSP .)
    BREAK           reduce using rule 33 (unary_expr -> expression TRANSP .)
    CONTINUE        reduce using rule 33 (unary_expr -> expression TRANSP .)
    PRINT           reduce using rule 33 (unary_expr -> expression TRANSP .)
    ID              reduce using rule 33 (unary_expr -> expression TRANSP .)


state 60

    (34) binary_expr -> expression + . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 92
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 61

    (35) binary_expr -> expression - . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 93
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 62

    (36) binary_expr -> expression * . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 94
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 63

    (37) binary_expr -> expression / . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 95
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 64

    (38) binary_expr -> expression > . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 96
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 65

    (39) binary_expr -> expression < . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 97
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 66

    (40) binary_expr -> expression EQUAL . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 98
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 67

    (41) binary_expr -> expression NOTEQUAL . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 99
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 68

    (42) binary_expr -> expression LESSEQUAL . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 100
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 69

    (43) binary_expr -> expression GREATEREQUAL . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 101
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 70

    (44) binary_expr -> expression DOTADD . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 102
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 71

    (45) binary_expr -> expression DOTSUB . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 103
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 72

    (46) binary_expr -> expression DOTMUL . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 104
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 73

    (47) binary_expr -> expression DOTDIV . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 105
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 74

    (53) matrix_init -> [ rows . ; row ]
    (55) rows -> rows . ; row

    ;               shift and go to state 106


state 75

    (54) matrix_init -> [ row . ]
    (56) rows -> row .
    (57) row -> row . , expression

    ]               shift and go to state 107
    ;               reduce using rule 56 (rows -> row .)
    ,               shift and go to state 108


state 76

    (58) row -> expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ]               reduce using rule 58 (row -> expression .)
    ,               reduce using rule 58 (row -> expression .)
    ;               reduce using rule 58 (row -> expression .)
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 77

    (32) unary_expr -> - expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 32 (unary_expr -> - expression .)
    TRANSP          reduce using rule 32 (unary_expr -> - expression .)
    +               reduce using rule 32 (unary_expr -> - expression .)
    -               reduce using rule 32 (unary_expr -> - expression .)
    >               reduce using rule 32 (unary_expr -> - expression .)
    <               reduce using rule 32 (unary_expr -> - expression .)
    EQUAL           reduce using rule 32 (unary_expr -> - expression .)
    NOTEQUAL        reduce using rule 32 (unary_expr -> - expression .)
    LESSEQUAL       reduce using rule 32 (unary_expr -> - expression .)
    GREATEREQUAL    reduce using rule 32 (unary_expr -> - expression .)
    ,               reduce using rule 32 (unary_expr -> - expression .)
    )               reduce using rule 32 (unary_expr -> - expression .)
    ]               reduce using rule 32 (unary_expr -> - expression .)
    :               reduce using rule 32 (unary_expr -> - expression .)
    {               reduce using rule 32 (unary_expr -> - expression .)
    IF              reduce using rule 32 (unary_expr -> - expression .)
    WHILE           reduce using rule 32 (unary_expr -> - expression .)
    FOR             reduce using rule 32 (unary_expr -> - expression .)
    RETURN          reduce using rule 32 (unary_expr -> - expression .)
    BREAK           reduce using rule 32 (unary_expr -> - expression .)
    CONTINUE        reduce using rule 32 (unary_expr -> - expression .)
    PRINT           reduce using rule 32 (unary_expr -> - expression .)
    ID              reduce using rule 32 (unary_expr -> - expression .)
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! *               [ reduce using rule 32 (unary_expr -> - expression .) ]
  ! /               [ reduce using rule 32 (unary_expr -> - expression .) ]
  ! DOTADD          [ reduce using rule 32 (unary_expr -> - expression .) ]
  ! DOTSUB          [ reduce using rule 32 (unary_expr -> - expression .) ]
  ! DOTMUL          [ reduce using rule 32 (unary_expr -> - expression .) ]
  ! DOTDIV          [ reduce using rule 32 (unary_expr -> - expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 78

    (48) matrix_init -> ZEROS ( . expression )
    (49) matrix_init -> ZEROS ( . expression , expression )
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 109
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 79

    (50) matrix_init -> ONES ( . expression )
    (51) matrix_init -> ONES ( . expression , expression )
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 110
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 80

    (52) matrix_init -> EYE ( . expression )
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 111
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 81

    (62) print_instruction -> PRINT string_expressions ; .

    IF              reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    WHILE           reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    FOR             reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    RETURN          reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    BREAK           reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    CONTINUE        reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    PRINT           reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    ID              reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    $end            reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    ;               reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    }               reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)
    ELSE            reduce using rule 62 (print_instruction -> PRINT string_expressions ; .)


state 82

    (63) string_expressions -> string_expressions , . string_expression
    (65) string_expression -> . STRING
    (66) string_expression -> . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    STRING          shift and go to state 48
    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    string_expression              shift and go to state 112
    expression                     shift and go to state 49
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 83

    (22) array_ref -> ID .
    (20) variable -> ID .
    (21) variable -> ID . [ array_ref ]

  ! reduce/reduce conflict for ] resolved using rule 20 (variable -> ID .)
  ! reduce/reduce conflict for , resolved using rule 20 (variable -> ID .)
    TRANSP          reduce using rule 20 (variable -> ID .)
    +               reduce using rule 20 (variable -> ID .)
    -               reduce using rule 20 (variable -> ID .)
    *               reduce using rule 20 (variable -> ID .)
    /               reduce using rule 20 (variable -> ID .)
    >               reduce using rule 20 (variable -> ID .)
    <               reduce using rule 20 (variable -> ID .)
    EQUAL           reduce using rule 20 (variable -> ID .)
    NOTEQUAL        reduce using rule 20 (variable -> ID .)
    LESSEQUAL       reduce using rule 20 (variable -> ID .)
    GREATEREQUAL    reduce using rule 20 (variable -> ID .)
    DOTADD          reduce using rule 20 (variable -> ID .)
    DOTSUB          reduce using rule 20 (variable -> ID .)
    DOTMUL          reduce using rule 20 (variable -> ID .)
    DOTDIV          reduce using rule 20 (variable -> ID .)
    ]               reduce using rule 20 (variable -> ID .)
    ,               reduce using rule 20 (variable -> ID .)
    [               shift and go to state 50

  ! ]               [ reduce using rule 22 (array_ref -> ID .) ]
  ! ,               [ reduce using rule 22 (array_ref -> ID .) ]


state 84

    (21) variable -> ID [ array_ref . ]
    (24) array_ref -> array_ref . , array_ref

    ]               shift and go to state 113
    ,               shift and go to state 114


state 85

    (23) array_ref -> expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ]               reduce using rule 23 (array_ref -> expression .)
    ,               reduce using rule 23 (array_ref -> expression .)
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 86

    (14) assign -> variable assign_op expression ; .

    IF              reduce using rule 14 (assign -> variable assign_op expression ; .)
    WHILE           reduce using rule 14 (assign -> variable assign_op expression ; .)
    FOR             reduce using rule 14 (assign -> variable assign_op expression ; .)
    RETURN          reduce using rule 14 (assign -> variable assign_op expression ; .)
    BREAK           reduce using rule 14 (assign -> variable assign_op expression ; .)
    CONTINUE        reduce using rule 14 (assign -> variable assign_op expression ; .)
    PRINT           reduce using rule 14 (assign -> variable assign_op expression ; .)
    ID              reduce using rule 14 (assign -> variable assign_op expression ; .)
    $end            reduce using rule 14 (assign -> variable assign_op expression ; .)
    ;               reduce using rule 14 (assign -> variable assign_op expression ; .)
    }               reduce using rule 14 (assign -> variable assign_op expression ; .)
    ELSE            reduce using rule 14 (assign -> variable assign_op expression ; .)


state 87

    (67) if_instruction -> IF ( expression ) . instructions
    (68) if_instruction -> IF ( expression ) . instructions ELSE instructions
    (69) if_instruction -> IF ( expression ) . instructions else_if_instruction
    (70) if_instruction -> IF ( expression ) . instructions else_if_instruction ELSE instructions
    (2) instructions -> . instructions instruction
    (3) instructions -> . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instructions                   shift and go to state 115
    instruction                    shift and go to state 3
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 88

    (73) iteration_instruction -> WHILE ( expression ) . braced_instructions
    (5) braced_instructions -> . { instructions }
    (6) braced_instructions -> . instruction ;
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    {               shift and go to state 55
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    braced_instructions            shift and go to state 116
    instruction                    shift and go to state 56
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 89

    (5) braced_instructions -> { instructions . }
    (2) instructions -> instructions . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    }               shift and go to state 117
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instruction                    shift and go to state 20
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 90

    (6) braced_instructions -> instruction ; .

    IF              reduce using rule 6 (braced_instructions -> instruction ; .)
    WHILE           reduce using rule 6 (braced_instructions -> instruction ; .)
    FOR             reduce using rule 6 (braced_instructions -> instruction ; .)
    RETURN          reduce using rule 6 (braced_instructions -> instruction ; .)
    BREAK           reduce using rule 6 (braced_instructions -> instruction ; .)
    CONTINUE        reduce using rule 6 (braced_instructions -> instruction ; .)
    PRINT           reduce using rule 6 (braced_instructions -> instruction ; .)
    ID              reduce using rule 6 (braced_instructions -> instruction ; .)
    $end            reduce using rule 6 (braced_instructions -> instruction ; .)
    ;               reduce using rule 6 (braced_instructions -> instruction ; .)
    }               reduce using rule 6 (braced_instructions -> instruction ; .)
    ELSE            reduce using rule 6 (braced_instructions -> instruction ; .)


state 91

    (75) range_expression -> ID = expression . : expression
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    :               shift and go to state 118
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 92

    (34) binary_expr -> expression + expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 34 (binary_expr -> expression + expression .)
    TRANSP          reduce using rule 34 (binary_expr -> expression + expression .)
    +               reduce using rule 34 (binary_expr -> expression + expression .)
    -               reduce using rule 34 (binary_expr -> expression + expression .)
    >               reduce using rule 34 (binary_expr -> expression + expression .)
    <               reduce using rule 34 (binary_expr -> expression + expression .)
    EQUAL           reduce using rule 34 (binary_expr -> expression + expression .)
    NOTEQUAL        reduce using rule 34 (binary_expr -> expression + expression .)
    LESSEQUAL       reduce using rule 34 (binary_expr -> expression + expression .)
    GREATEREQUAL    reduce using rule 34 (binary_expr -> expression + expression .)
    ,               reduce using rule 34 (binary_expr -> expression + expression .)
    )               reduce using rule 34 (binary_expr -> expression + expression .)
    ]               reduce using rule 34 (binary_expr -> expression + expression .)
    :               reduce using rule 34 (binary_expr -> expression + expression .)
    {               reduce using rule 34 (binary_expr -> expression + expression .)
    IF              reduce using rule 34 (binary_expr -> expression + expression .)
    WHILE           reduce using rule 34 (binary_expr -> expression + expression .)
    FOR             reduce using rule 34 (binary_expr -> expression + expression .)
    RETURN          reduce using rule 34 (binary_expr -> expression + expression .)
    BREAK           reduce using rule 34 (binary_expr -> expression + expression .)
    CONTINUE        reduce using rule 34 (binary_expr -> expression + expression .)
    PRINT           reduce using rule 34 (binary_expr -> expression + expression .)
    ID              reduce using rule 34 (binary_expr -> expression + expression .)
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! *               [ reduce using rule 34 (binary_expr -> expression + expression .) ]
  ! /               [ reduce using rule 34 (binary_expr -> expression + expression .) ]
  ! DOTADD          [ reduce using rule 34 (binary_expr -> expression + expression .) ]
  ! DOTSUB          [ reduce using rule 34 (binary_expr -> expression + expression .) ]
  ! DOTMUL          [ reduce using rule 34 (binary_expr -> expression + expression .) ]
  ! DOTDIV          [ reduce using rule 34 (binary_expr -> expression + expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 93

    (35) binary_expr -> expression - expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 35 (binary_expr -> expression - expression .)
    TRANSP          reduce using rule 35 (binary_expr -> expression - expression .)
    +               reduce using rule 35 (binary_expr -> expression - expression .)
    -               reduce using rule 35 (binary_expr -> expression - expression .)
    >               reduce using rule 35 (binary_expr -> expression - expression .)
    <               reduce using rule 35 (binary_expr -> expression - expression .)
    EQUAL           reduce using rule 35 (binary_expr -> expression - expression .)
    NOTEQUAL        reduce using rule 35 (binary_expr -> expression - expression .)
    LESSEQUAL       reduce using rule 35 (binary_expr -> expression - expression .)
    GREATEREQUAL    reduce using rule 35 (binary_expr -> expression - expression .)
    ,               reduce using rule 35 (binary_expr -> expression - expression .)
    )               reduce using rule 35 (binary_expr -> expression - expression .)
    ]               reduce using rule 35 (binary_expr -> expression - expression .)
    :               reduce using rule 35 (binary_expr -> expression - expression .)
    {               reduce using rule 35 (binary_expr -> expression - expression .)
    IF              reduce using rule 35 (binary_expr -> expression - expression .)
    WHILE           reduce using rule 35 (binary_expr -> expression - expression .)
    FOR             reduce using rule 35 (binary_expr -> expression - expression .)
    RETURN          reduce using rule 35 (binary_expr -> expression - expression .)
    BREAK           reduce using rule 35 (binary_expr -> expression - expression .)
    CONTINUE        reduce using rule 35 (binary_expr -> expression - expression .)
    PRINT           reduce using rule 35 (binary_expr -> expression - expression .)
    ID              reduce using rule 35 (binary_expr -> expression - expression .)
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! *               [ reduce using rule 35 (binary_expr -> expression - expression .) ]
  ! /               [ reduce using rule 35 (binary_expr -> expression - expression .) ]
  ! DOTADD          [ reduce using rule 35 (binary_expr -> expression - expression .) ]
  ! DOTSUB          [ reduce using rule 35 (binary_expr -> expression - expression .) ]
  ! DOTMUL          [ reduce using rule 35 (binary_expr -> expression - expression .) ]
  ! DOTDIV          [ reduce using rule 35 (binary_expr -> expression - expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 94

    (36) binary_expr -> expression * expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 36 (binary_expr -> expression * expression .)
    TRANSP          reduce using rule 36 (binary_expr -> expression * expression .)
    +               reduce using rule 36 (binary_expr -> expression * expression .)
    -               reduce using rule 36 (binary_expr -> expression * expression .)
    *               reduce using rule 36 (binary_expr -> expression * expression .)
    /               reduce using rule 36 (binary_expr -> expression * expression .)
    >               reduce using rule 36 (binary_expr -> expression * expression .)
    <               reduce using rule 36 (binary_expr -> expression * expression .)
    EQUAL           reduce using rule 36 (binary_expr -> expression * expression .)
    NOTEQUAL        reduce using rule 36 (binary_expr -> expression * expression .)
    LESSEQUAL       reduce using rule 36 (binary_expr -> expression * expression .)
    GREATEREQUAL    reduce using rule 36 (binary_expr -> expression * expression .)
    ,               reduce using rule 36 (binary_expr -> expression * expression .)
    )               reduce using rule 36 (binary_expr -> expression * expression .)
    ]               reduce using rule 36 (binary_expr -> expression * expression .)
    :               reduce using rule 36 (binary_expr -> expression * expression .)
    {               reduce using rule 36 (binary_expr -> expression * expression .)
    IF              reduce using rule 36 (binary_expr -> expression * expression .)
    WHILE           reduce using rule 36 (binary_expr -> expression * expression .)
    FOR             reduce using rule 36 (binary_expr -> expression * expression .)
    RETURN          reduce using rule 36 (binary_expr -> expression * expression .)
    BREAK           reduce using rule 36 (binary_expr -> expression * expression .)
    CONTINUE        reduce using rule 36 (binary_expr -> expression * expression .)
    PRINT           reduce using rule 36 (binary_expr -> expression * expression .)
    ID              reduce using rule 36 (binary_expr -> expression * expression .)
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! DOTADD          [ reduce using rule 36 (binary_expr -> expression * expression .) ]
  ! DOTSUB          [ reduce using rule 36 (binary_expr -> expression * expression .) ]
  ! DOTMUL          [ reduce using rule 36 (binary_expr -> expression * expression .) ]
  ! DOTDIV          [ reduce using rule 36 (binary_expr -> expression * expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 95

    (37) binary_expr -> expression / expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 37 (binary_expr -> expression / expression .)
    TRANSP          reduce using rule 37 (binary_expr -> expression / expression .)
    +               reduce using rule 37 (binary_expr -> expression / expression .)
    -               reduce using rule 37 (binary_expr -> expression / expression .)
    *               reduce using rule 37 (binary_expr -> expression / expression .)
    /               reduce using rule 37 (binary_expr -> expression / expression .)
    >               reduce using rule 37 (binary_expr -> expression / expression .)
    <               reduce using rule 37 (binary_expr -> expression / expression .)
    EQUAL           reduce using rule 37 (binary_expr -> expression / expression .)
    NOTEQUAL        reduce using rule 37 (binary_expr -> expression / expression .)
    LESSEQUAL       reduce using rule 37 (binary_expr -> expression / expression .)
    GREATEREQUAL    reduce using rule 37 (binary_expr -> expression / expression .)
    ,               reduce using rule 37 (binary_expr -> expression / expression .)
    )               reduce using rule 37 (binary_expr -> expression / expression .)
    ]               reduce using rule 37 (binary_expr -> expression / expression .)
    :               reduce using rule 37 (binary_expr -> expression / expression .)
    {               reduce using rule 37 (binary_expr -> expression / expression .)
    IF              reduce using rule 37 (binary_expr -> expression / expression .)
    WHILE           reduce using rule 37 (binary_expr -> expression / expression .)
    FOR             reduce using rule 37 (binary_expr -> expression / expression .)
    RETURN          reduce using rule 37 (binary_expr -> expression / expression .)
    BREAK           reduce using rule 37 (binary_expr -> expression / expression .)
    CONTINUE        reduce using rule 37 (binary_expr -> expression / expression .)
    PRINT           reduce using rule 37 (binary_expr -> expression / expression .)
    ID              reduce using rule 37 (binary_expr -> expression / expression .)
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! DOTADD          [ reduce using rule 37 (binary_expr -> expression / expression .) ]
  ! DOTSUB          [ reduce using rule 37 (binary_expr -> expression / expression .) ]
  ! DOTMUL          [ reduce using rule 37 (binary_expr -> expression / expression .) ]
  ! DOTDIV          [ reduce using rule 37 (binary_expr -> expression / expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 96

    (38) binary_expr -> expression > expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 38 (binary_expr -> expression > expression .)
    TRANSP          reduce using rule 38 (binary_expr -> expression > expression .)
    >               reduce using rule 38 (binary_expr -> expression > expression .)
    <               reduce using rule 38 (binary_expr -> expression > expression .)
    EQUAL           reduce using rule 38 (binary_expr -> expression > expression .)
    NOTEQUAL        reduce using rule 38 (binary_expr -> expression > expression .)
    LESSEQUAL       reduce using rule 38 (binary_expr -> expression > expression .)
    GREATEREQUAL    reduce using rule 38 (binary_expr -> expression > expression .)
    ,               reduce using rule 38 (binary_expr -> expression > expression .)
    )               reduce using rule 38 (binary_expr -> expression > expression .)
    ]               reduce using rule 38 (binary_expr -> expression > expression .)
    :               reduce using rule 38 (binary_expr -> expression > expression .)
    {               reduce using rule 38 (binary_expr -> expression > expression .)
    IF              reduce using rule 38 (binary_expr -> expression > expression .)
    WHILE           reduce using rule 38 (binary_expr -> expression > expression .)
    FOR             reduce using rule 38 (binary_expr -> expression > expression .)
    RETURN          reduce using rule 38 (binary_expr -> expression > expression .)
    BREAK           reduce using rule 38 (binary_expr -> expression > expression .)
    CONTINUE        reduce using rule 38 (binary_expr -> expression > expression .)
    PRINT           reduce using rule 38 (binary_expr -> expression > expression .)
    ID              reduce using rule 38 (binary_expr -> expression > expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! +               [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! -               [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! *               [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! /               [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! DOTADD          [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! DOTSUB          [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! DOTMUL          [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! DOTDIV          [ reduce using rule 38 (binary_expr -> expression > expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 97

    (39) binary_expr -> expression < expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 39 (binary_expr -> expression < expression .)
    TRANSP          reduce using rule 39 (binary_expr -> expression < expression .)
    >               reduce using rule 39 (binary_expr -> expression < expression .)
    <               reduce using rule 39 (binary_expr -> expression < expression .)
    EQUAL           reduce using rule 39 (binary_expr -> expression < expression .)
    NOTEQUAL        reduce using rule 39 (binary_expr -> expression < expression .)
    LESSEQUAL       reduce using rule 39 (binary_expr -> expression < expression .)
    GREATEREQUAL    reduce using rule 39 (binary_expr -> expression < expression .)
    ,               reduce using rule 39 (binary_expr -> expression < expression .)
    )               reduce using rule 39 (binary_expr -> expression < expression .)
    ]               reduce using rule 39 (binary_expr -> expression < expression .)
    :               reduce using rule 39 (binary_expr -> expression < expression .)
    {               reduce using rule 39 (binary_expr -> expression < expression .)
    IF              reduce using rule 39 (binary_expr -> expression < expression .)
    WHILE           reduce using rule 39 (binary_expr -> expression < expression .)
    FOR             reduce using rule 39 (binary_expr -> expression < expression .)
    RETURN          reduce using rule 39 (binary_expr -> expression < expression .)
    BREAK           reduce using rule 39 (binary_expr -> expression < expression .)
    CONTINUE        reduce using rule 39 (binary_expr -> expression < expression .)
    PRINT           reduce using rule 39 (binary_expr -> expression < expression .)
    ID              reduce using rule 39 (binary_expr -> expression < expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! +               [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! -               [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! *               [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! /               [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! DOTADD          [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! DOTSUB          [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! DOTMUL          [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! DOTDIV          [ reduce using rule 39 (binary_expr -> expression < expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 98

    (40) binary_expr -> expression EQUAL expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    TRANSP          reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    >               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    <               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    EQUAL           reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    NOTEQUAL        reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    LESSEQUAL       reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    GREATEREQUAL    reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    ,               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    )               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    ]               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    :               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    {               reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    IF              reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    WHILE           reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    FOR             reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    RETURN          reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    BREAK           reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    CONTINUE        reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    PRINT           reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    ID              reduce using rule 40 (binary_expr -> expression EQUAL expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! +               [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! -               [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! *               [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! /               [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! DOTADD          [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! DOTSUB          [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! DOTMUL          [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! DOTDIV          [ reduce using rule 40 (binary_expr -> expression EQUAL expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 99

    (41) binary_expr -> expression NOTEQUAL expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    TRANSP          reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    >               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    <               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    EQUAL           reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    NOTEQUAL        reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    LESSEQUAL       reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    GREATEREQUAL    reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    ,               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    )               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    ]               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    :               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    {               reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    IF              reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    WHILE           reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    FOR             reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    RETURN          reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    BREAK           reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    CONTINUE        reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    PRINT           reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    ID              reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! +               [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! -               [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! *               [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! /               [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! DOTADD          [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! DOTSUB          [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! DOTMUL          [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! DOTDIV          [ reduce using rule 41 (binary_expr -> expression NOTEQUAL expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 100

    (42) binary_expr -> expression LESSEQUAL expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    TRANSP          reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    >               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    <               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    EQUAL           reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    NOTEQUAL        reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    LESSEQUAL       reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    GREATEREQUAL    reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    ,               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    )               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    ]               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    :               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    {               reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    IF              reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    WHILE           reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    FOR             reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    RETURN          reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    BREAK           reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    CONTINUE        reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    PRINT           reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    ID              reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! +               [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! -               [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! *               [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! /               [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! DOTADD          [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! DOTSUB          [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! DOTMUL          [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! DOTDIV          [ reduce using rule 42 (binary_expr -> expression LESSEQUAL expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 101

    (43) binary_expr -> expression GREATEREQUAL expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    TRANSP          reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    >               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    <               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    EQUAL           reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    NOTEQUAL        reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    LESSEQUAL       reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    GREATEREQUAL    reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    ,               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    )               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    ]               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    :               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    {               reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    IF              reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    WHILE           reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    FOR             reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    RETURN          reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    BREAK           reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    CONTINUE        reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    PRINT           reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    ID              reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .)
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! +               [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! -               [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! *               [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! /               [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! DOTADD          [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! DOTSUB          [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! DOTMUL          [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! DOTDIV          [ reduce using rule 43 (binary_expr -> expression GREATEREQUAL expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]


state 102

    (44) binary_expr -> expression DOTADD expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    TRANSP          reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    +               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    -               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    *               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    /               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    >               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    <               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    EQUAL           reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    NOTEQUAL        reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    LESSEQUAL       reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    GREATEREQUAL    reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    DOTADD          reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    DOTSUB          reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    ,               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    )               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    ]               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    :               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    {               reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    IF              reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    WHILE           reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    FOR             reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    RETURN          reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    BREAK           reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    CONTINUE        reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    PRINT           reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    ID              reduce using rule 44 (binary_expr -> expression DOTADD expression .)
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! DOTMUL          [ reduce using rule 44 (binary_expr -> expression DOTADD expression .) ]
  ! DOTDIV          [ reduce using rule 44 (binary_expr -> expression DOTADD expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]
  ! DOTADD          [ shift and go to state 70 ]
  ! DOTSUB          [ shift and go to state 71 ]


state 103

    (45) binary_expr -> expression DOTSUB expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    TRANSP          reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    +               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    -               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    *               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    /               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    >               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    <               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    EQUAL           reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    NOTEQUAL        reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    LESSEQUAL       reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    GREATEREQUAL    reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    DOTADD          reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    DOTSUB          reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    ,               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    )               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    ]               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    :               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    {               reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    IF              reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    WHILE           reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    FOR             reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    RETURN          reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    BREAK           reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    CONTINUE        reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    PRINT           reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    ID              reduce using rule 45 (binary_expr -> expression DOTSUB expression .)
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73

  ! DOTMUL          [ reduce using rule 45 (binary_expr -> expression DOTSUB expression .) ]
  ! DOTDIV          [ reduce using rule 45 (binary_expr -> expression DOTSUB expression .) ]
  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]
  ! DOTADD          [ shift and go to state 70 ]
  ! DOTSUB          [ shift and go to state 71 ]


state 104

    (46) binary_expr -> expression DOTMUL expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    TRANSP          reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    +               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    -               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    *               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    /               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    >               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    <               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    EQUAL           reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    NOTEQUAL        reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    LESSEQUAL       reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    GREATEREQUAL    reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    DOTADD          reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    DOTSUB          reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    DOTMUL          reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    DOTDIV          reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    ,               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    )               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    ]               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    :               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    {               reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    IF              reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    WHILE           reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    FOR             reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    RETURN          reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    BREAK           reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    CONTINUE        reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    PRINT           reduce using rule 46 (binary_expr -> expression DOTMUL expression .)
    ID              reduce using rule 46 (binary_expr -> expression DOTMUL expression .)

  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]
  ! DOTADD          [ shift and go to state 70 ]
  ! DOTSUB          [ shift and go to state 71 ]
  ! DOTMUL          [ shift and go to state 72 ]
  ! DOTDIV          [ shift and go to state 73 ]


state 105

    (47) binary_expr -> expression DOTDIV expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ;               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    TRANSP          reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    +               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    -               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    *               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    /               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    >               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    <               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    EQUAL           reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    NOTEQUAL        reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    LESSEQUAL       reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    GREATEREQUAL    reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    DOTADD          reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    DOTSUB          reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    DOTMUL          reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    DOTDIV          reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    ,               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    )               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    ]               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    :               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    {               reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    IF              reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    WHILE           reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    FOR             reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    RETURN          reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    BREAK           reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    CONTINUE        reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    PRINT           reduce using rule 47 (binary_expr -> expression DOTDIV expression .)
    ID              reduce using rule 47 (binary_expr -> expression DOTDIV expression .)

  ! TRANSP          [ shift and go to state 59 ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 61 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 63 ]
  ! >               [ shift and go to state 64 ]
  ! <               [ shift and go to state 65 ]
  ! EQUAL           [ shift and go to state 66 ]
  ! NOTEQUAL        [ shift and go to state 67 ]
  ! LESSEQUAL       [ shift and go to state 68 ]
  ! GREATEREQUAL    [ shift and go to state 69 ]
  ! DOTADD          [ shift and go to state 70 ]
  ! DOTSUB          [ shift and go to state 71 ]
  ! DOTMUL          [ shift and go to state 72 ]
  ! DOTDIV          [ shift and go to state 73 ]


state 106

    (53) matrix_init -> [ rows ; . row ]
    (55) rows -> rows ; . row
    (57) row -> . row , expression
    (58) row -> . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    row                            shift and go to state 119
    expression                     shift and go to state 76
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 107

    (54) matrix_init -> [ row ] .

    ;               reduce using rule 54 (matrix_init -> [ row ] .)
    TRANSP          reduce using rule 54 (matrix_init -> [ row ] .)
    +               reduce using rule 54 (matrix_init -> [ row ] .)
    -               reduce using rule 54 (matrix_init -> [ row ] .)
    *               reduce using rule 54 (matrix_init -> [ row ] .)
    /               reduce using rule 54 (matrix_init -> [ row ] .)
    >               reduce using rule 54 (matrix_init -> [ row ] .)
    <               reduce using rule 54 (matrix_init -> [ row ] .)
    EQUAL           reduce using rule 54 (matrix_init -> [ row ] .)
    NOTEQUAL        reduce using rule 54 (matrix_init -> [ row ] .)
    LESSEQUAL       reduce using rule 54 (matrix_init -> [ row ] .)
    GREATEREQUAL    reduce using rule 54 (matrix_init -> [ row ] .)
    DOTADD          reduce using rule 54 (matrix_init -> [ row ] .)
    DOTSUB          reduce using rule 54 (matrix_init -> [ row ] .)
    DOTMUL          reduce using rule 54 (matrix_init -> [ row ] .)
    DOTDIV          reduce using rule 54 (matrix_init -> [ row ] .)
    ,               reduce using rule 54 (matrix_init -> [ row ] .)
    )               reduce using rule 54 (matrix_init -> [ row ] .)
    ]               reduce using rule 54 (matrix_init -> [ row ] .)
    :               reduce using rule 54 (matrix_init -> [ row ] .)
    {               reduce using rule 54 (matrix_init -> [ row ] .)
    IF              reduce using rule 54 (matrix_init -> [ row ] .)
    WHILE           reduce using rule 54 (matrix_init -> [ row ] .)
    FOR             reduce using rule 54 (matrix_init -> [ row ] .)
    RETURN          reduce using rule 54 (matrix_init -> [ row ] .)
    BREAK           reduce using rule 54 (matrix_init -> [ row ] .)
    CONTINUE        reduce using rule 54 (matrix_init -> [ row ] .)
    PRINT           reduce using rule 54 (matrix_init -> [ row ] .)
    ID              reduce using rule 54 (matrix_init -> [ row ] .)


state 108

    (57) row -> row , . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 120
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 109

    (48) matrix_init -> ZEROS ( expression . )
    (49) matrix_init -> ZEROS ( expression . , expression )
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 121
    ,               shift and go to state 122
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 110

    (50) matrix_init -> ONES ( expression . )
    (51) matrix_init -> ONES ( expression . , expression )
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 123
    ,               shift and go to state 124
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 111

    (52) matrix_init -> EYE ( expression . )
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 125
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 112

    (63) string_expressions -> string_expressions , string_expression .

    ;               reduce using rule 63 (string_expressions -> string_expressions , string_expression .)
    ,               reduce using rule 63 (string_expressions -> string_expressions , string_expression .)


state 113

    (21) variable -> ID [ array_ref ] .

    =               reduce using rule 21 (variable -> ID [ array_ref ] .)
    ADDASSIGN       reduce using rule 21 (variable -> ID [ array_ref ] .)
    SUBASSIGN       reduce using rule 21 (variable -> ID [ array_ref ] .)
    MULASSIGN       reduce using rule 21 (variable -> ID [ array_ref ] .)
    DIVASSIGN       reduce using rule 21 (variable -> ID [ array_ref ] .)
    ;               reduce using rule 21 (variable -> ID [ array_ref ] .)
    TRANSP          reduce using rule 21 (variable -> ID [ array_ref ] .)
    +               reduce using rule 21 (variable -> ID [ array_ref ] .)
    -               reduce using rule 21 (variable -> ID [ array_ref ] .)
    *               reduce using rule 21 (variable -> ID [ array_ref ] .)
    /               reduce using rule 21 (variable -> ID [ array_ref ] .)
    >               reduce using rule 21 (variable -> ID [ array_ref ] .)
    <               reduce using rule 21 (variable -> ID [ array_ref ] .)
    EQUAL           reduce using rule 21 (variable -> ID [ array_ref ] .)
    NOTEQUAL        reduce using rule 21 (variable -> ID [ array_ref ] .)
    LESSEQUAL       reduce using rule 21 (variable -> ID [ array_ref ] .)
    GREATEREQUAL    reduce using rule 21 (variable -> ID [ array_ref ] .)
    DOTADD          reduce using rule 21 (variable -> ID [ array_ref ] .)
    DOTSUB          reduce using rule 21 (variable -> ID [ array_ref ] .)
    DOTMUL          reduce using rule 21 (variable -> ID [ array_ref ] .)
    DOTDIV          reduce using rule 21 (variable -> ID [ array_ref ] .)
    ,               reduce using rule 21 (variable -> ID [ array_ref ] .)
    )               reduce using rule 21 (variable -> ID [ array_ref ] .)
    ]               reduce using rule 21 (variable -> ID [ array_ref ] .)
    :               reduce using rule 21 (variable -> ID [ array_ref ] .)
    {               reduce using rule 21 (variable -> ID [ array_ref ] .)
    IF              reduce using rule 21 (variable -> ID [ array_ref ] .)
    WHILE           reduce using rule 21 (variable -> ID [ array_ref ] .)
    FOR             reduce using rule 21 (variable -> ID [ array_ref ] .)
    RETURN          reduce using rule 21 (variable -> ID [ array_ref ] .)
    BREAK           reduce using rule 21 (variable -> ID [ array_ref ] .)
    CONTINUE        reduce using rule 21 (variable -> ID [ array_ref ] .)
    PRINT           reduce using rule 21 (variable -> ID [ array_ref ] .)
    ID              reduce using rule 21 (variable -> ID [ array_ref ] .)


state 114

    (24) array_ref -> array_ref , . array_ref
    (22) array_ref -> . ID
    (23) array_ref -> . expression
    (24) array_ref -> . array_ref , array_ref
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 83
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    array_ref                      shift and go to state 126
    expression                     shift and go to state 85
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 115

    (67) if_instruction -> IF ( expression ) instructions .
    (68) if_instruction -> IF ( expression ) instructions . ELSE instructions
    (69) if_instruction -> IF ( expression ) instructions . else_if_instruction
    (70) if_instruction -> IF ( expression ) instructions . else_if_instruction ELSE instructions
    (2) instructions -> instructions . instruction
    (71) else_if_instruction -> . ELSE IF ( expression ) instructions
    (72) else_if_instruction -> . ELSE IF ( expression ) instructions else_if_instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    $end            reduce using rule 67 (if_instruction -> IF ( expression ) instructions .)
    ;               reduce using rule 67 (if_instruction -> IF ( expression ) instructions .)
    }               reduce using rule 67 (if_instruction -> IF ( expression ) instructions .)
    ELSE            shift and go to state 127
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

  ! IF              [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! WHILE           [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! FOR             [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! RETURN          [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! BREAK           [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! CONTINUE        [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! PRINT           [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! ID              [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! ELSE            [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]

    else_if_instruction            shift and go to state 128
    instruction                    shift and go to state 20
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 116

    (73) iteration_instruction -> WHILE ( expression ) braced_instructions .

    IF              reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    WHILE           reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    FOR             reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    RETURN          reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    BREAK           reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    CONTINUE        reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    PRINT           reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    ID              reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    $end            reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    ;               reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    }               reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)
    ELSE            reduce using rule 73 (iteration_instruction -> WHILE ( expression ) braced_instructions .)


state 117

    (5) braced_instructions -> { instructions } .

    IF              reduce using rule 5 (braced_instructions -> { instructions } .)
    WHILE           reduce using rule 5 (braced_instructions -> { instructions } .)
    FOR             reduce using rule 5 (braced_instructions -> { instructions } .)
    RETURN          reduce using rule 5 (braced_instructions -> { instructions } .)
    BREAK           reduce using rule 5 (braced_instructions -> { instructions } .)
    CONTINUE        reduce using rule 5 (braced_instructions -> { instructions } .)
    PRINT           reduce using rule 5 (braced_instructions -> { instructions } .)
    ID              reduce using rule 5 (braced_instructions -> { instructions } .)
    $end            reduce using rule 5 (braced_instructions -> { instructions } .)
    ;               reduce using rule 5 (braced_instructions -> { instructions } .)
    }               reduce using rule 5 (braced_instructions -> { instructions } .)
    ELSE            reduce using rule 5 (braced_instructions -> { instructions } .)


state 118

    (75) range_expression -> ID = expression : . expression
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 129
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 119

    (53) matrix_init -> [ rows ; row . ]
    (55) rows -> rows ; row .
    (57) row -> row . , expression

    ]               shift and go to state 130
    ;               reduce using rule 55 (rows -> rows ; row .)
    ,               shift and go to state 108


state 120

    (57) row -> row , expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    ]               reduce using rule 57 (row -> row , expression .)
    ,               reduce using rule 57 (row -> row , expression .)
    ;               reduce using rule 57 (row -> row , expression .)
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 121

    (48) matrix_init -> ZEROS ( expression ) .

    ;               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    TRANSP          reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    +               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    -               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    *               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    /               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    >               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    <               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    EQUAL           reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    NOTEQUAL        reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    LESSEQUAL       reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    GREATEREQUAL    reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    DOTADD          reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    DOTSUB          reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    DOTMUL          reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    DOTDIV          reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    ,               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    )               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    ]               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    :               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    {               reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    IF              reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    WHILE           reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    FOR             reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    RETURN          reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    BREAK           reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    CONTINUE        reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    PRINT           reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)
    ID              reduce using rule 48 (matrix_init -> ZEROS ( expression ) .)


state 122

    (49) matrix_init -> ZEROS ( expression , . expression )
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 131
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 123

    (50) matrix_init -> ONES ( expression ) .

    ;               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    TRANSP          reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    +               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    -               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    *               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    /               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    >               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    <               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    EQUAL           reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    NOTEQUAL        reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    LESSEQUAL       reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    GREATEREQUAL    reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    DOTADD          reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    DOTSUB          reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    DOTMUL          reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    DOTDIV          reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    ,               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    )               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    ]               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    :               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    {               reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    IF              reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    WHILE           reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    FOR             reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    RETURN          reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    BREAK           reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    CONTINUE        reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    PRINT           reduce using rule 50 (matrix_init -> ONES ( expression ) .)
    ID              reduce using rule 50 (matrix_init -> ONES ( expression ) .)


state 124

    (51) matrix_init -> ONES ( expression , . expression )
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 132
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 125

    (52) matrix_init -> EYE ( expression ) .

    ;               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    TRANSP          reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    +               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    -               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    *               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    /               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    >               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    <               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    EQUAL           reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    NOTEQUAL        reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    LESSEQUAL       reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    GREATEREQUAL    reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    DOTADD          reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    DOTSUB          reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    DOTMUL          reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    DOTDIV          reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    ,               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    )               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    ]               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    :               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    {               reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    IF              reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    WHILE           reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    FOR             reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    RETURN          reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    BREAK           reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    CONTINUE        reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    PRINT           reduce using rule 52 (matrix_init -> EYE ( expression ) .)
    ID              reduce using rule 52 (matrix_init -> EYE ( expression ) .)


state 126

    (24) array_ref -> array_ref , array_ref .
    (24) array_ref -> array_ref . , array_ref

  ! shift/reduce conflict for , resolved as shift
    ]               reduce using rule 24 (array_ref -> array_ref , array_ref .)
    ,               shift and go to state 114

  ! ,               [ reduce using rule 24 (array_ref -> array_ref , array_ref .) ]


state 127

    (68) if_instruction -> IF ( expression ) instructions ELSE . instructions
    (71) else_if_instruction -> ELSE . IF ( expression ) instructions
    (72) else_if_instruction -> ELSE . IF ( expression ) instructions else_if_instruction
    (2) instructions -> . instructions instruction
    (3) instructions -> . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              shift and go to state 133
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instructions                   shift and go to state 134
    instruction                    shift and go to state 3
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 128

    (69) if_instruction -> IF ( expression ) instructions else_if_instruction .
    (70) if_instruction -> IF ( expression ) instructions else_if_instruction . ELSE instructions

  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    WHILE           reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    FOR             reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    RETURN          reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    BREAK           reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    CONTINUE        reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    PRINT           reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    ID              reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    $end            reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    ;               reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    }               reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    ELSE            shift and go to state 135

  ! ELSE            [ reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .) ]


state 129

    (75) range_expression -> ID = expression : expression .
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    {               reduce using rule 75 (range_expression -> ID = expression : expression .)
    IF              reduce using rule 75 (range_expression -> ID = expression : expression .)
    WHILE           reduce using rule 75 (range_expression -> ID = expression : expression .)
    FOR             reduce using rule 75 (range_expression -> ID = expression : expression .)
    RETURN          reduce using rule 75 (range_expression -> ID = expression : expression .)
    BREAK           reduce using rule 75 (range_expression -> ID = expression : expression .)
    CONTINUE        reduce using rule 75 (range_expression -> ID = expression : expression .)
    PRINT           reduce using rule 75 (range_expression -> ID = expression : expression .)
    ID              reduce using rule 75 (range_expression -> ID = expression : expression .)
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 130

    (53) matrix_init -> [ rows ; row ] .

    ;               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    TRANSP          reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    +               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    -               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    *               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    /               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    >               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    <               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    EQUAL           reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    NOTEQUAL        reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    LESSEQUAL       reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    GREATEREQUAL    reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    DOTADD          reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    DOTSUB          reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    DOTMUL          reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    DOTDIV          reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    ,               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    )               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    ]               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    :               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    {               reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    IF              reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    WHILE           reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    FOR             reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    RETURN          reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    BREAK           reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    CONTINUE        reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    PRINT           reduce using rule 53 (matrix_init -> [ rows ; row ] .)
    ID              reduce using rule 53 (matrix_init -> [ rows ; row ] .)


state 131

    (49) matrix_init -> ZEROS ( expression , expression . )
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 136
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 132

    (51) matrix_init -> ONES ( expression , expression . )
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 137
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 133

    (71) else_if_instruction -> ELSE IF . ( expression ) instructions
    (72) else_if_instruction -> ELSE IF . ( expression ) instructions else_if_instruction
    (67) if_instruction -> IF . ( expression ) instructions
    (68) if_instruction -> IF . ( expression ) instructions ELSE instructions
    (69) if_instruction -> IF . ( expression ) instructions else_if_instruction
    (70) if_instruction -> IF . ( expression ) instructions else_if_instruction ELSE instructions

    (               shift and go to state 138


state 134

    (68) if_instruction -> IF ( expression ) instructions ELSE instructions .
    (2) instructions -> instructions . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    WHILE           reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    FOR             reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    RETURN          reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    BREAK           reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    CONTINUE        reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    PRINT           reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    ID              reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    $end            reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    ;               reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    }               reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)
    ELSE            reduce using rule 68 (if_instruction -> IF ( expression ) instructions ELSE instructions .)

  ! IF              [ shift and go to state 12 ]
  ! WHILE           [ shift and go to state 13 ]
  ! FOR             [ shift and go to state 14 ]
  ! RETURN          [ shift and go to state 15 ]
  ! BREAK           [ shift and go to state 16 ]
  ! CONTINUE        [ shift and go to state 17 ]
  ! PRINT           [ shift and go to state 18 ]
  ! ID              [ shift and go to state 19 ]

    instruction                    shift and go to state 20
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 135

    (70) if_instruction -> IF ( expression ) instructions else_if_instruction ELSE . instructions
    (2) instructions -> . instructions instruction
    (3) instructions -> . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instructions                   shift and go to state 139
    instruction                    shift and go to state 3
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 136

    (49) matrix_init -> ZEROS ( expression , expression ) .

    ;               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    TRANSP          reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    +               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    -               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    *               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    /               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    >               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    <               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    EQUAL           reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    NOTEQUAL        reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    LESSEQUAL       reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    GREATEREQUAL    reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    DOTADD          reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    DOTSUB          reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    DOTMUL          reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    DOTDIV          reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    ,               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    )               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    ]               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    :               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    {               reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    IF              reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    WHILE           reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    FOR             reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    RETURN          reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    BREAK           reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    CONTINUE        reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    PRINT           reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)
    ID              reduce using rule 49 (matrix_init -> ZEROS ( expression , expression ) .)


state 137

    (51) matrix_init -> ONES ( expression , expression ) .

    ;               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    TRANSP          reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    +               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    -               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    *               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    /               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    >               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    <               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    EQUAL           reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    NOTEQUAL        reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    LESSEQUAL       reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    GREATEREQUAL    reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    DOTADD          reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    DOTSUB          reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    DOTMUL          reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    DOTDIV          reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    ,               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    )               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    ]               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    :               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    {               reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    IF              reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    WHILE           reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    FOR             reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    RETURN          reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    BREAK           reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    CONTINUE        reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    PRINT           reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)
    ID              reduce using rule 51 (matrix_init -> ONES ( expression , expression ) .)


state 138

    (71) else_if_instruction -> ELSE IF ( . expression ) instructions
    (72) else_if_instruction -> ELSE IF ( . expression ) instructions else_if_instruction
    (67) if_instruction -> IF ( . expression ) instructions
    (68) if_instruction -> IF ( . expression ) instructions ELSE instructions
    (69) if_instruction -> IF ( . expression ) instructions else_if_instruction
    (70) if_instruction -> IF ( . expression ) instructions else_if_instruction ELSE instructions
    (25) expression -> . variable
    (26) expression -> . constant
    (27) expression -> . unary_expr
    (28) expression -> . binary_expr
    (29) expression -> . matrix_init
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]
    (30) constant -> . INT
    (31) constant -> . FLOAT
    (32) unary_expr -> . - expression
    (33) unary_expr -> . expression TRANSP
    (34) binary_expr -> . expression + expression
    (35) binary_expr -> . expression - expression
    (36) binary_expr -> . expression * expression
    (37) binary_expr -> . expression / expression
    (38) binary_expr -> . expression > expression
    (39) binary_expr -> . expression < expression
    (40) binary_expr -> . expression EQUAL expression
    (41) binary_expr -> . expression NOTEQUAL expression
    (42) binary_expr -> . expression LESSEQUAL expression
    (43) binary_expr -> . expression GREATEREQUAL expression
    (44) binary_expr -> . expression DOTADD expression
    (45) binary_expr -> . expression DOTSUB expression
    (46) binary_expr -> . expression DOTMUL expression
    (47) binary_expr -> . expression DOTDIV expression
    (48) matrix_init -> . ZEROS ( expression )
    (49) matrix_init -> . ZEROS ( expression , expression )
    (50) matrix_init -> . ONES ( expression )
    (51) matrix_init -> . ONES ( expression , expression )
    (52) matrix_init -> . EYE ( expression )
    (53) matrix_init -> . [ rows ; row ]
    (54) matrix_init -> . [ row ]

    ID              shift and go to state 19
    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    -               shift and go to state 40
    ZEROS           shift and go to state 41
    ONES            shift and go to state 42
    EYE             shift and go to state 43
    [               shift and go to state 37

    expression                     shift and go to state 140
    variable                       shift and go to state 32
    constant                       shift and go to state 33
    unary_expr                     shift and go to state 34
    binary_expr                    shift and go to state 35
    matrix_init                    shift and go to state 36

state 139

    (70) if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .
    (2) instructions -> instructions . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    WHILE           reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    FOR             reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    RETURN          reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    BREAK           reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    CONTINUE        reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    PRINT           reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    ID              reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    $end            reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    ;               reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    }               reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)
    ELSE            reduce using rule 70 (if_instruction -> IF ( expression ) instructions else_if_instruction ELSE instructions .)

  ! IF              [ shift and go to state 12 ]
  ! WHILE           [ shift and go to state 13 ]
  ! FOR             [ shift and go to state 14 ]
  ! RETURN          [ shift and go to state 15 ]
  ! BREAK           [ shift and go to state 16 ]
  ! CONTINUE        [ shift and go to state 17 ]
  ! PRINT           [ shift and go to state 18 ]
  ! ID              [ shift and go to state 19 ]

    instruction                    shift and go to state 20
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 140

    (71) else_if_instruction -> ELSE IF ( expression . ) instructions
    (72) else_if_instruction -> ELSE IF ( expression . ) instructions else_if_instruction
    (67) if_instruction -> IF ( expression . ) instructions
    (68) if_instruction -> IF ( expression . ) instructions ELSE instructions
    (69) if_instruction -> IF ( expression . ) instructions else_if_instruction
    (70) if_instruction -> IF ( expression . ) instructions else_if_instruction ELSE instructions
    (33) unary_expr -> expression . TRANSP
    (34) binary_expr -> expression . + expression
    (35) binary_expr -> expression . - expression
    (36) binary_expr -> expression . * expression
    (37) binary_expr -> expression . / expression
    (38) binary_expr -> expression . > expression
    (39) binary_expr -> expression . < expression
    (40) binary_expr -> expression . EQUAL expression
    (41) binary_expr -> expression . NOTEQUAL expression
    (42) binary_expr -> expression . LESSEQUAL expression
    (43) binary_expr -> expression . GREATEREQUAL expression
    (44) binary_expr -> expression . DOTADD expression
    (45) binary_expr -> expression . DOTSUB expression
    (46) binary_expr -> expression . DOTMUL expression
    (47) binary_expr -> expression . DOTDIV expression

    )               shift and go to state 141
    TRANSP          shift and go to state 59
    +               shift and go to state 60
    -               shift and go to state 61
    *               shift and go to state 62
    /               shift and go to state 63
    >               shift and go to state 64
    <               shift and go to state 65
    EQUAL           shift and go to state 66
    NOTEQUAL        shift and go to state 67
    LESSEQUAL       shift and go to state 68
    GREATEREQUAL    shift and go to state 69
    DOTADD          shift and go to state 70
    DOTSUB          shift and go to state 71
    DOTMUL          shift and go to state 72
    DOTDIV          shift and go to state 73


state 141

    (71) else_if_instruction -> ELSE IF ( expression ) . instructions
    (72) else_if_instruction -> ELSE IF ( expression ) . instructions else_if_instruction
    (67) if_instruction -> IF ( expression ) . instructions
    (68) if_instruction -> IF ( expression ) . instructions ELSE instructions
    (69) if_instruction -> IF ( expression ) . instructions else_if_instruction
    (70) if_instruction -> IF ( expression ) . instructions else_if_instruction ELSE instructions
    (2) instructions -> . instructions instruction
    (3) instructions -> . instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

    instructions                   shift and go to state 142
    instruction                    shift and go to state 3
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 142

    (71) else_if_instruction -> ELSE IF ( expression ) instructions .
    (72) else_if_instruction -> ELSE IF ( expression ) instructions . else_if_instruction
    (67) if_instruction -> IF ( expression ) instructions .
    (68) if_instruction -> IF ( expression ) instructions . ELSE instructions
    (69) if_instruction -> IF ( expression ) instructions . else_if_instruction
    (70) if_instruction -> IF ( expression ) instructions . else_if_instruction ELSE instructions
    (2) instructions -> instructions . instruction
    (71) else_if_instruction -> . ELSE IF ( expression ) instructions
    (72) else_if_instruction -> . ELSE IF ( expression ) instructions else_if_instruction
    (7) instruction -> . assign
    (8) instruction -> . if_instruction
    (9) instruction -> . iteration_instruction
    (10) instruction -> . return_instruction
    (11) instruction -> . break_instruction
    (12) instruction -> . continue_instruction
    (13) instruction -> . print_instruction
    (14) assign -> . variable assign_op expression ;
    (67) if_instruction -> . IF ( expression ) instructions
    (68) if_instruction -> . IF ( expression ) instructions ELSE instructions
    (69) if_instruction -> . IF ( expression ) instructions else_if_instruction
    (70) if_instruction -> . IF ( expression ) instructions else_if_instruction ELSE instructions
    (73) iteration_instruction -> . WHILE ( expression ) braced_instructions
    (74) iteration_instruction -> . FOR range_expression braced_instructions
    (61) return_instruction -> . RETURN expression ;
    (59) break_instruction -> . BREAK ;
    (60) continue_instruction -> . CONTINUE ;
    (62) print_instruction -> . PRINT string_expressions ;
    (20) variable -> . ID
    (21) variable -> . ID [ array_ref ]

  ! reduce/reduce conflict for ELSE resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for IF resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for WHILE resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for FOR resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for RETURN resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for BREAK resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for PRINT resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for ID resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for $end resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for ; resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! reduce/reduce conflict for } resolved using rule 67 (if_instruction -> IF ( expression ) instructions .)
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    $end            reduce using rule 67 (if_instruction -> IF ( expression ) instructions .)
    ;               reduce using rule 67 (if_instruction -> IF ( expression ) instructions .)
    }               reduce using rule 67 (if_instruction -> IF ( expression ) instructions .)
    ELSE            shift and go to state 127
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    RETURN          shift and go to state 15
    BREAK           shift and go to state 16
    CONTINUE        shift and go to state 17
    PRINT           shift and go to state 18
    ID              shift and go to state 19

  ! ELSE            [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! IF              [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! WHILE           [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! FOR             [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! RETURN          [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! BREAK           [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! CONTINUE        [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! PRINT           [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! ID              [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! $end            [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! ;               [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! }               [ reduce using rule 71 (else_if_instruction -> ELSE IF ( expression ) instructions .) ]
  ! ELSE            [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! IF              [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! WHILE           [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! FOR             [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! RETURN          [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! BREAK           [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! CONTINUE        [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! PRINT           [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]
  ! ID              [ reduce using rule 67 (if_instruction -> IF ( expression ) instructions .) ]

    else_if_instruction            shift and go to state 143
    instruction                    shift and go to state 20
    assign                         shift and go to state 4
    if_instruction                 shift and go to state 5
    iteration_instruction          shift and go to state 6
    return_instruction             shift and go to state 7
    break_instruction              shift and go to state 8
    continue_instruction           shift and go to state 9
    print_instruction              shift and go to state 10
    variable                       shift and go to state 11

state 143

    (72) else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .
    (69) if_instruction -> IF ( expression ) instructions else_if_instruction .
    (70) if_instruction -> IF ( expression ) instructions else_if_instruction . ELSE instructions

  ! reduce/reduce conflict for ELSE resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for IF resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for WHILE resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for FOR resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for RETURN resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for BREAK resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for PRINT resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for ID resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for $end resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for ; resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! reduce/reduce conflict for } resolved using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
  ! shift/reduce conflict for ELSE resolved as shift
    IF              reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    WHILE           reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    FOR             reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    RETURN          reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    BREAK           reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    CONTINUE        reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    PRINT           reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    ID              reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    $end            reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    ;               reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    }               reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .)
    ELSE            shift and go to state 135

  ! ELSE            [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! IF              [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! WHILE           [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! FOR             [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! RETURN          [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! BREAK           [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! CONTINUE        [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! PRINT           [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! ID              [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! $end            [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! ;               [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! }               [ reduce using rule 72 (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction .) ]
  ! ELSE            [ reduce using rule 69 (if_instruction -> IF ( expression ) instructions else_if_instruction .) ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 115 resolved as shift
WARNING: shift/reduce conflict for IF in state 115 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 115 resolved as shift
WARNING: shift/reduce conflict for FOR in state 115 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 115 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 115 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 115 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 115 resolved as shift
WARNING: shift/reduce conflict for ID in state 115 resolved as shift
WARNING: shift/reduce conflict for , in state 126 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 128 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 142 resolved as shift
WARNING: shift/reduce conflict for IF in state 142 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 142 resolved as shift
WARNING: shift/reduce conflict for FOR in state 142 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 142 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 142 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 142 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 142 resolved as shift
WARNING: shift/reduce conflict for ID in state 142 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 143 resolved as shift
WARNING: reduce/reduce conflict in state 83 resolved using rule (variable -> ID)
WARNING: rejected rule (array_ref -> ID) in state 83
WARNING: reduce/reduce conflict in state 142 resolved using rule (if_instruction -> IF ( expression ) instructions)
WARNING: rejected rule (else_if_instruction -> ELSE IF ( expression ) instructions) in state 142
WARNING: reduce/reduce conflict in state 143 resolved using rule (if_instruction -> IF ( expression ) instructions else_if_instruction)
WARNING: rejected rule (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction) in state 143
WARNING: Rule (array_ref -> ID) is never reduced
WARNING: Rule (else_if_instruction -> ELSE IF ( expression ) instructions) is never reduced
WARNING: Rule (else_if_instruction -> ELSE IF ( expression ) instructions else_if_instruction) is never reduced
